plugins {
	id 'java'
	id 'application'
	id 'jacoco'
	id 'org.openjfx.javafxplugin' version '0.1.0'
	id 'org.checkerframework' version '0.6.59' apply false
	
	// auto create automatic modules:
	//id 'extra-java-module-info' apply false
	// see:
	// https://docs.gradle.org/7.0.2/samples/sample_java_modules_with_transform.html
}

//apply plugin: 'extra-java-module-info'
apply plugin: 'org.checkerframework'

wrapper {
	gradleVersion = '8.14.3'
}

final def javaLangVersion = JavaLanguageVersion.of(23)
final def jvmVendor = JvmVendorSpec.ADOPTIUM
//final def jvmVendor = JvmVendorSpec.matching('Arch Linux')

final def versionCheckerFramework = '3.51.0'

java {
	toolchain {
		languageVersion = javaLangVersion
		vendor = jvmVendor
	}
}
tasks.withType(JavaExec).configureEach {
	javaLauncher = javaToolchains.launcherFor {
		languageVersion = javaLangVersion
		vendor = jvmVendor
	}
}

// project local properties:
final String propVersion = 'diascope.version'
final String versionBase = project.hasProperty(propVersion) ? project.getProperty(propVersion) : '0'

final String propPreRelease = 'diascope.pre-release'
final String versionPreRelease = project.hasProperty(propPreRelease) ?
	"${versionBase}-${project.getProperty(propPreRelease)}" : versionBase

// global (user) properties (build identifier supersedes reading subversion revision):
final String propBuild = 'diascope.build.identifier'
final String propReadSvnRevision = 'diascope.build.readSvnRevision'
ext.isReadingSvnRevision = project.hasProperty(propReadSvnRevision) ? Boolean.valueOf(project.getProperty(propReadSvnRevision)) : false
	
logger.lifecycle "-> Getting semantic version build number from subversion revision (user property »${propReadSvnRevision}«) : " + isReadingSvnRevision

def String readSvnRevision()
{
	def svnRev = ''
	if (isReadingSvnRevision) {
		final def process = [ 'svn', 'info', '--show-item', 'repos-root-url', '--no-newline' ].execute(null, projectDir)
		if (process.waitFor()) {
			logger.lifecycle "   -> Can't get subversion revision"
		}
		else {
			final boolean isolateNumericBuildParts = false
			final String urlSvnRepos = process.text.trim()
			logger.lifecycle "   Reading subversion revision (repos-root-url: »${urlSvnRepos}«)"
			final def process2 = [ 'svn', 'info', '--show-item', 'revision', '--no-newline', urlSvnRepos ].execute()
			if (process2.waitFor()) {
				logger.lifecycle "   -> Can't get head revision from subversion server" +
				        " -> falling back to reading local working copy revision"
				final def process3 = [ 'svnversion', '-n' ].execute(null, projectDir)
				if (process3.waitFor()) {
					logger.lifecycle " -> Can't get subversion revision"
					svnRev = ''
				}
				else {
					svnRev = process3.text.trim()
					if (svnRev) {
						// create valid semantic version build-nr:
						svnRev = 'r' + svnRev.replaceAll('[^0-9a-zA-Z]+' , '.')
						svnRev = svnRev.endsWith('.') ? svnRev.substring(0, n-1) : svnRev
						if (isolateNumericBuildParts) {
							final int n = svnRev.length()
							final def s = new StringBuilder();
							final def p = ~/([a-zA-Z][0-9])|([0-9][a-zA-Z])/
							for (int i = 1; i < n; i++) {
								s.append(svnRev.substring(i-1, i))
								if (svnRev.substring(i-1, i+1) ==~ p) s.append('.')
							}
							svnRev = s.append(svnRev.substring(n-1, n)).toString()
						}
					}
				}
			} else {
				svnRev = process2.text.trim()
				svnRev = (isolateNumericBuildParts ? 'r.' : 'r') + ((svnRev as Integer) + 1)
			}
			logger.lifecycle "   -> subversion revision is »${svnRev}«"
		}
	}
	return svnRev
}

final String build_id = project.hasProperty(propBuild) ? project.getProperty(propBuild) : readSvnRevision()
final String semVer = build_id ? "${versionPreRelease}+${build_id}" : versionPreRelease

final def regexSemVer = ~/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/
if (!(semVer =~ regexSemVer)) throw new StopExecutionException("Invalid semantic version »${semVer}«")

// files:

final String fileNameSemVer = 'src/main/resources/de/bernd_michaely/diascope/app/semantic_version.txt'
final def fileSemVer = project(':module-gui-fx').file(fileNameSemVer)

final def fileVersionShield = file("doc/shields/version.svg")

description = 'A JavaFX based image viewer with multi layer image comparison.'
		
allprojects {
	group = 'de.bernd_michaely'
	version = semVer
	
	ext.versionJUnit = '5.13.4'
	// ext.versionJUnitVintage = '4.13.2'
	
	repositories {
		mavenCentral()
		//mavenLocal()
	}

	if (project == rootProject || name.equals("module-launcher") || name.endsWith('-fx')) {
		apply plugin: 'org.openjfx.javafxplugin'
		javafx {
			//version = "21.0.8"
			version = "24.0.2"
		}
		logger.lifecycle "-> Applying JavaFX ${javafx.version} plugin to project »$path«"
	}
}

logger.lifecycle "Running Gradle $project.gradle.gradleVersion"
logger.lifecycle "Java source level           : ${java.sourceCompatibility}"
logger.lifecycle "Compile      -> Debug-Level : ${compileJava.options.debug}"
logger.lifecycle "Test-Compile -> Debug-Level : ${compileTestJava.options.debug}"
logger.lifecycle "Modularity enabled          : ${java.modularity.inferModulePath.get()}"
logger.lifecycle "==> Root project »$name ($version)«"
logger.lifecycle " -> Base dir is »${file('.')}«"
if (ext.has('versionJUnitVintage')) {
	logger.lifecycle " -> Using »JUnit         ${versionJUnit}«"
	logger.lifecycle " -> Using »JUnit vintage ${versionJUnitVintage}«"
} else {
	logger.lifecycle " -> Using »JUnit  ${versionJUnit}«"
}
logger.lifecycle " -> Using »JaCoCo ${jacoco.toolVersion}«"
logger.lifecycle " -> Included child projects : »${childProjects.keySet().stream().sorted().toList()}«"
logger.lifecycle " -> Maven coordinates »${group}:${name}:${version}«"

subprojects {
	tasks.withType(JavaCompile).configureEach {
		javaCompiler = javaToolchains.compilerFor {
			languageVersion = javaLangVersion
			vendor = jvmVendor
		}
	}
	tasks.withType(Test).configureEach {
		javaLauncher = javaToolchains.launcherFor {
			languageVersion = javaLangVersion
			vendor = jvmVendor
		}
	}
	logger.lifecycle "==> Configuring sub-project »$name ($version)«"
	tasks.withType(JavaCompile) {
		logger.lifecycle "=> Configuring task »$name«"
		options.compilerArgs += '-Xlint:unchecked'
		options.compilerArgs += '-Xlint:deprecation'
		options.compilerArgs += '-Xdiags:verbose'
		logger.lifecycle "   -> compiler args : ${options.compilerArgs}"
	}
}

/*
extraJavaModuleInfo {
automaticModule('batik-all-1.17.jar', 'batik')	
}
 */

dependencies {
	implementation project (':lib-common-cli-parser')
	implementation project (':lib-common-semver')
	implementation project (':module-gui-fx')
	implementation "org.checkerframework:checker-qual:${versionCheckerFramework}"
	//implementation 'com.github.weisj:jsvg:1.5.0'
	//implementation 'org.apache.xmlgraphics:batik-all:1.17'
	//implementation 'xml-apis:xml-apis:1.4.01'
	//implementation 'xml-apis:xml-apis-ext:1.3.04'
	//implementation 'org.apache.xmlgraphics:xmlgraphics-commons:2.9'
}

task writeSemVer {
	description = "Write application semantic version to resource file »${fileSemVer}«"
	group = processResources.group
	doFirst {
		boolean do_write
		if (isReadingSvnRevision) {
			final def process = [ 'svn', 'status' ].execute(null, projectDir)
			// only write new version if svn status is NOT clean:
			do_write = !process.waitFor() && process.text
		} else do_write = true
		if (do_write) fileSemVer.write(semVer)
	}
}
processResources.dependsOn writeSemVer

task getVersionShield {
	description = "Generate a version shield by accessing shields.io and write it to file »${fileVersionShield}«"
	group = javadoc.group
	final def toShieldParam = { it replaceAll "-", "--" replaceAll "_", "__" replaceAll "\\s", "_"  }
	doLast {
		final String label = toShieldParam rootProject.name
		final String message = toShieldParam (semVer - ~/\+.*$/)
		final String color = 'blue'
		final def url = new URI("https://img.shields.io/badge/${label}-${message}-${color}").toURL()
		logger.lifecycle "→ getting data from URL »${url}«"
		fileVersionShield.write url.text
	}
}

application {
	mainModule = 'de.bernd_michaely.diascope'
	mainClass  = 'de.bernd_michaely.diascope.Launcher'
	
	if (javaLangVersion == JavaLanguageVersion.of(24) && javafx.version ==~ /24(\.\d+(\.\d+)?)?/) {
		applicationDefaultJvmArgs += '--enable-native-access=javafx.graphics'
		applicationDefaultJvmArgs += '--sun-misc-unsafe-memory-access=allow'
	}
	logger.lifecycle "==> applicationDefaultJvmArgs -> " + applicationDefaultJvmArgs
}

jar {
	javafx {
		//	modules = [ 'javafx.base', 'javafx.graphics', 'javafx.controls', 'javafx.swing', 'javafx.web' ]
		modules = [ 'javafx.base', 'javafx.graphics', 'javafx.controls' ]
	}
	manifest {
		attributes ( 'Main-Class' : "${application.mainModule.get()}/${application.mainClass.get()}" )
	}
}
		
run {
	logger.lifecycle " -> run task modularity : ${modularity.inferModulePath.get()}"
	//args = [ '--development', 'running from within gradle' ]
	
	systemProperty 'java.util.logging.config.file', file('logging.properties')
	
	def propertyNameDiascopeArgs = 'diascope.arg'
	int i = 0
	while (project.hasProperty("${propertyNameDiascopeArgs}.${i}")) {
		args += project.getProperty("${propertyNameDiascopeArgs}.${i++}")
	}
	logger.lifecycle " -> Running with args :"
	int k = 0
	for (def arg: args) logger.lifecycle "    [${k++}] : »${arg}«"
}
